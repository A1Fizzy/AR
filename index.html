<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Куб с A-Frame и отслеживанием рук</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <style>
        body { margin: 0; }
        video { display: none; }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <video id="myvideo" autoplay playsinline></video>
    <canvas id="videoCanvas"></canvas>
    <a-scene embedded arjs='sourceType: webcam;'>
        <a-entity id="custom-cube" 
                  geometry="primitive: box; width: 0.2; height: 0.2; depth: 0.2" 
                  material="color: #00ff00" 
                  position="0 0 -1"></a-entity>
        <a-entity camera></a-entity>
    </a-scene>

    <script type="module">
        // Инициализация MediaPipe Hands
        const video = document.getElementById("myvideo");
        const canvas = document.getElementById("videoCanvas");
        const ctx = canvas.getContext("2d");

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // Запуск камеры
        async function startCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                console.log("Available cameras:", videoDevices);

                let videoConstraints = { width: 640, height: 480 };

                const rearCamera = videoDevices.find(device => 
                    device.label.toLowerCase().includes('back') || 
                    device.label.toLowerCase().includes('rear') || 
                    device.label.toLowerCase().includes('environment')
                );

                if (rearCamera) {
                    console.log("Using rear camera:", rearCamera.label);
                    videoConstraints.deviceId = { exact: rearCamera.deviceId };
                } else {
                    console.warn("Rear camera not found, falling back to default camera.");
                    alert("Rear camera not found. Using default camera. Switch to rear camera if possible.");
                    videoConstraints.facingMode = "environment";
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    processFrame();
                };
            } catch (err) {
                console.error("Camera start error:", err);
                alert("Failed to start camera: " + err.message);
            }
        }

        async function processFrame() {
            await hands.send({ image: video });
            requestAnimationFrame(processFrame);
        }

        hands.onResults((results) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Рисуем ключевые точки
                for (const landmark of landmarks) {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = "green";
                    ctx.fill();
                }

                // Используем кончик указательного пальца (точка 8) и большой палец (точка 4)
                const indexTip = landmarks[8]; // Кончик указательного пальца
                const thumbTip = landmarks[4]; // Кончик большого пальца

                // Вычисляем расстояние между указательным и большим пальцами
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) + 
                    Math.pow(indexTip.y - thumbTip.y, 2)
                );

                // Проверяем, сжаты ли пальцы
                const isHandClosed = distance < 0.1; // Порог для определения сжатия

                // Преобразуем координаты для A-Frame
                const scene = document.querySelector('a-scene');
                const width = scene.canvas.width;
                const height = scene.canvas.height;

                // Нормализуем координаты
                const normalizedX = (indexTip.x - 0.5) * 4; // Преобразуем в диапазон [-2, 2]
                const normalizedY = -(indexTip.y - 0.5) * 4; // Преобразуем в диапазон [-2, 2]

                // Устанавливаем позицию куба
                const cube = document.getElementById('custom-cube');
                cube.setAttribute('position', { x: normalizedX, y: normalizedY, z: -1 });

                // Изменяем цвет куба при сжатии пальцев
                if (isHandClosed) {
                    cube.setAttribute('material', 'color', '#ff0000'); // Красный цвет при сжатии
                } else {
                    cube.setAttribute('material', 'color', '#00ff00'); // Зеленый цвет в обычном состоянии
                }

                // Дополнительный функционал: поворот куба в зависимости от угла ладони
                const palmBase = landmarks[0]; // Запястье
                const palmCenterX = (palmBase.x + indexTip.x) / 2;
                const palmCenterY = (palmBase.y + indexTip.y) / 2;

                // Устанавливаем поворот куба в зависимости от положения ладони
                const angle = Math.atan2(palmCenterY - palmBase.y, palmCenterX - palmBase.x);
                cube.setAttribute('rotation', { x: 0, y: angle * (180 / Math.PI), z: 0 }); // Поворот по оси Y
            }
        });

        // Запуск камеры
        startCamera();

        // Обработка изменения размера окна
        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const scene = document.querySelector('a-scene');
            scene.renderer.setSize(window.innerWidth, window.innerHeight);
            scene.camera.aspect = window.innerWidth / window.innerHeight;
            scene.camera.updateProjectionMatrix();
        });

        // Установка начальных размеров канваса
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    </script>
</body>
</html>

