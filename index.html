<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Куб с A-Frame и отслеживанием рук</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <style>
        body { margin: 0; }
        video { display: none; }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <video id="myvideo" autoplay playsinline></video>
    <canvas id="videoCanvas"></canvas>
<!--     <a-scene embedded arjs='sourceType: webcam;'>
        <a-entity id="custom-cube" 
                  geometry="primitive: box; width: 0.2; height: 0.2; depth: 0.2" 
                  material="color: #00ff00" 
                  position="0 0 -3"></a-entity>
        <a-entity camera></a-entity>
    </a-scene> -->

    <script type="module">
        // Инициализация MediaPipe Hands
        const video = document.getElementById("myvideo");
        const canvas = document.getElementById("videoCanvas");
        const ctx = canvas.getContext("2d");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const smoothingFactor = 0.1; // Коэффициент сглаживания
        let targetX = 0; // Целевая позиция X для сглаживания
        let targetY = 0; // Целевая позиция Y для сглаживания
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.id = "rendererCanvas";
        document.body.appendChild(renderer.domElement);
    
        // Позиция камеры
        camera.position.set(0, 0, 0);
        camera.lookAt(0, 0, -1);

        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.8 });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.set(0, 0, -1);
        scene.add(cube);

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        // Запуск камеры
        async function startCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                console.log("Available cameras:", videoDevices);

                let videoConstraints = { width: 640, height: 480 };

                const rearCamera = videoDevices.find(device => 
                    device.label.toLowerCase().includes('back') || 
                    device.label.toLowerCase().includes('rear') || 
                    device.label.toLowerCase().includes('environment')
                );

                if (rearCamera) {
                    console.log("Using rear camera:", rearCamera.label);
                    videoConstraints.deviceId = { exact: rearCamera.deviceId };
                } else {
                    console.warn("Rear camera not found, falling back to default camera.");
                    alert("Rear camera not found. Using default camera. Switch to rear camera if possible.");
                    videoConstraints.facingMode = "environment";
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    processFrame();
                };
            } catch (err) {
                console.error("Camera start error:", err);
                alert("Failed to start camera: " + err.message);
            }
        }

        async function processFrame() {
            await hands.send({ image: video });
            requestAnimationFrame(processFrame);
        }

        hands.onResults((results) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // Рисуем ключевые точки
                for (const landmark of landmarks) {
                    const x = landmark.x * canvas.width;
                    const y = landmark.y * canvas.height;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = "green";
                    ctx.fill();
                }

                // Используем кончик указательного пальца (точка 8) для перемещения куба
                const handX = landmarks[8].x; // Кончик указательного пальца
                const handY = landmarks[8].y;

                // Преобразуем координаты для A-Frame
                // const scene = document.querySelector('a-scene');
                // const width = scene.canvas.width;
                // const height = scene.canvas.height;

                // Нормализуем координаты
                const normalizedX = (handX - 0.5) * 4; // Преобразуем в диапазон [-2, 2]
                const normalizedY = -(handY - 0.5) * 4; // Преобразуем в диапазон [-2, 2]

                // Устанавливаем позицию куба
                const currentX = cube.position.x;
                const currentY = cube.position.y;
                cube.position.x += (targetX - currentX) * smoothingFactor;
                cube.position.y += (targetY - currentY) * smoothingFactor;
            }
        });

        // Запуск камеры
        startCamera();

        // Обработка изменения размера окна
        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        });

        // Установка начальных размеров канваса
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    </script>
</body>
</html>

