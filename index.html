<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Gesture Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #ar-container {
            position: fixed;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="ar-container"></div>

    <!-- Подключаем библиотеки -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>

    <script>
        // Глобальные переменные
        let renderer, scene, camera, arToolkitSource, arToolkitContext;
        let object3D, markerRoot;
        let isPinching = false;
        let lastScale = 1;

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        // Настройки MediaPipe
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.75,
            minTrackingConfidence: 0.75
        });

        // Инициализация Three.js и AR.js
        function initAR() {
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('ar-container').appendChild(renderer.domElement);
        
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
            
            // Добавляем координатные оси для отладки
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
        
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
                sourceWidth: 1280,
                sourceHeight: 720
            });
        
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'data/camera_para.dat',
                detectionMode: 'mono',
                maxDetectionRate: 60,
                canvasWidth: 1280,
                canvasHeight: 720
            });
        
            arToolkitSource.init(() => {
                arToolkitContext.init(() => {
                    camera.projectionMatrix.needsUpdate = true;
                    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                    camera.updateMatrixWorld(true);
                    
                    // Принудительный рендеринг первого кадра
                    renderer.render(scene, camera);
                });
            });
        }

        function loadCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            object3D = new THREE.Mesh(geometry, material);
            object3D.position.set(0, 0, 0); // Центр
            markerRoot.add(object3D);
        }

        // Обработка жестов
        hands.onResults((results) => {
            if (!results.multiHandLandmarks || !object3D) return;

            const landmarks = results.multiHandLandmarks[0];
            updateObjectTransform(landmarks);
        });

        function updateObjectTransform(landmarks) {
            const thumbTip = landmarks[4];  // Большой палец
            const indexTip = landmarks[8];  // Указательный

            const pinchDistance = Math.hypot(
                thumbTip.x - indexTip.x,
                thumbTip.y - indexTip.y
            );

            if (pinchDistance < 0.05) {
                if (!isPinching) {
                    lastScale = object3D.scale.x;
                    isPinching = true;
                }
                object3D.scale.setScalar(lastScale * (1 + (0.1 - pinchDistance)));
            } else {
                isPinching = false;
            }

            // Вращение по запястью
            const wrist = landmarks[0];
            const middleBase = landmarks[9];

            const angle = Math.atan2(
                middleBase.y - wrist.y,
                middleBase.x - wrist.x
            );

            object3D.rotation.y = angle;
        }

        // Анимация
        function animate() {
            requestAnimationFrame(animate);

            if (arToolkitSource.ready && arToolkitContext.ready) {
                arToolkitContext.update(arToolkitSource.domElement);
                hands.send({ image: arToolkitSource.domElement });
                renderer.render(scene, camera);
            }
        }

        // Запуск приложения
        function startApp() {
            initAR();
            animate();
        }

        window.addEventListener('load', () => {
            startApp();
        });
    </script>
</body>

</html>
